#include <stdio.h>    // fprintf_s, FILE, stdout
#include <stdlib.h>   // atoi, malloc, free
#include "lex.parac"  // lex, lex_all_input
#include "list.parac" // *
#include "cheats.h"   // todo, fn, global

// #-------------------------------------------------------------------------
// #  Types
// #-------------------------------------------------------------------------

// FORWARD DECLARATIONS

struct StructMember
{
    field: char *,
    type: struct Type *,
}

// struct_member_list ::= struct_member*
// struct_member ::= 'ident' ':' type ','
fn parse_struct_member_list(lxr: struct Lexer *) -> struct List
{
    let list: struct List = list_init();

    while (lexer_accept(lxr, TOK_IDENT))
    {
        let field: char * = lxr->token;

        lexer_expect(lxr, TOK_COLON);

        let type: struct Type *;
        if (!(type = parse_type(lxr)))
            todo; // TODO: report error

        lexer_expect(lxr, TOK_COMMA);

        let sm: struct StructMember * = malloc(sizeof(*sm));
        sm->field = field;
        sm->type = type;

        list_push(&list, (void *)sm);
    }

    return list;
}

data Type {

    // Atomic types
    Int { _: char, },
    Bool { _: char, },
    Char { _: char, },
    Void { _: char, },
    CStrArr { _: char, },
    File { _: char, },

    // Compound types
    Ptr { child: data Type *, },
    FnPtr {
        param_types: struct List, // A `List` of `Type *`s.
        ret_type: data Type *,
    },
    NamedStructRef { name: char *, },
    NamedEnumRef { name: char *, },
    NamedDataRef { name: char *, },

    // TODO: Remove anonymous types once algebraic data types are impl'd.
    AnonStruct {
        struct_members: struct List, // A `List` of `StructMember`s.
    },
    AnonUnion {
        struct_members: struct List, // A `List` of `StructMember`s.
    },
    AnonEnum {
        enum_members: struct List, // A `List` of `char *`s.
    },
}

fn display_fn_pointer_type(out: FILE *, type: data Type *, binder: char *) -> bool
{
    // We're at the first non-fn-ptr type in the return-type chain.
    if (type == NULL) {
        return fprintf_s(out, "void ") >= 0;
    }

    // This is the initial entry point to the function (usually).
    if let Type::FnPtr { param_types = param_types: struct List, ret_type = ret_type: data Type * } = *type {
        if (binder) {
            // Initiate recursion.
            // Step 1: Print out:
            //             a) the final return type, and
            //             b) as many leading '(*'s.
            if (!display_fn_pointer_type(out, ret_type, NULL))
                return false;

            // Step 2: Print out the bottom-most function pointer with it's binder.
            if (!(fprintf_s(out, "(*%s)(", binder) >= 0 &&
                display_param_types(out, &param_types) &&
                fprintf_s(out, ")") >= 0))
                return false;

            // Step 3: Print ')(PARAMS)' for all fn pointers
            let t: struct Type * = ret_type;
            while (t != NULL)
            {
                if let Type::FnPtr { param_types = pts: struct List, ret_type = child_ret_type: data Type * } = *t {
                    if (!(fprintf_s(out, ")(") >= 0 &&
                        display_param_types(out, &pts) &&
                        fprintf_s(out, ")") >= 0))
                        return false;

                    t = child_ret_type;
                } else {
                    break;
                }
            }

            return true;
        } else {
            // We're working our way down the tree, need to print a '(*' at each step on
            // our way back UP.
            return display_fn_pointer_type(out, ret_type, NULL) &&
                    fprintf_s(out, "(*") >= 0;
        }
    } else {
        // We're at the first non-fn-ptr type in the return-type chain.
        return display_type(out, type) &&
                fprintf_s(out, " ") >= 0;
        // The stack will now unwind, and essentially go to "Step 2" in branch 2.
    }
}

fn display_fn_signature(out: FILE *, name: char *, fn_params: struct List *, ret_type: struct Type *) -> bool
{
    // Initiate recursion.
    // Step 1: Print out:
    //             a) the final return type, and
    //             b) as many leading '(*'s.
    if (!display_fn_pointer_type(out, ret_type, NULL))
        return false;

    // Step 2: Print out the bottom-most function pointer with it's binder.
    if (!(fprintf_s(out, "%s(", name) >= 0 &&
          display_fn_params(out, fn_params) &&
          fprintf_s(out, ")") >= 0))
        return false;

    // Step 3: Print ')(PARAMS)' for all fn pointers
    let t: struct Type * = ret_type;
    while (t) {
        if let Type::FnPtr { param_types = param_types: struct List, ret_type = rt: data Type * } = *t {
            if (!(fprintf_s(out, ")(") >= 0 &&
                display_param_types(out, &param_types) &&
                fprintf_s(out, ")") >= 0))
                return false;

            t = rt;
        } else {
            break;
        }
    }

    return true;
}

fn display_typed_identifier(out: FILE *, type: data Type *, ident: char *) -> bool
{
    let space: char * = " ";
    if (ident == NULL || ident[0] == '\0')
        space = "";

    if let Type::Int {} = *type {
        return fprintf_s(out, "int%s%s", space, ident) >= 0;
    }
    if let Type::Bool {} = *type {
        return fprintf_s(out, "bool%s%s", space, ident) >= 0;
    }
    if let Type::Char {} = *type {
        return fprintf_s(out, "char%s%s", space, ident) >= 0;
    }
    if let Type::Void {} = *type {
        return fprintf_s(out, "void%s%s", space, ident) >= 0;
    }
    if let Type::CStrArr {} = *type {
        return fprintf_s(out, "cstr_arr%s%s", space, ident) >= 0;
    }
    if let Type::File {} = *type {
        return fprintf_s(out, "FILE%s%s", space, ident) >= 0;
    }
    if let Type::Ptr { child = child: data Type * } = *type {
        // return fprintf_s(out, "(") >= 0 &&
        //        display_type(out, type->as.ptr.child) &&
        //        fprintf_s(out, "*)") >= 0;
        return display_typed_identifier(out, child, "") &&
               fprintf_s(out, " *%s", ident) >= 0;
    }
    if let Type::FnPtr {} = *type { // TODO: Allow wildcard matching (i.e. `..`).
        return display_fn_pointer_type(out, type, ident);
    }
    if let Type::NamedStructRef { name = name: char * } = *type {
        return fprintf_s(out, "struct %s%s%s", name, space, ident) >= 0;
    }
    if let Type::NamedEnumRef { name = name: char * } = *type {
        return fprintf_s(out, "enum %s%s%s", name, space, ident) >= 0;
    }
    if let Type::NamedDataRef { name = name: char * } = *type {
        return fprintf_s(out, "struct %s%s%s", name, space, ident) >= 0;
    }
    if let Type::AnonStruct { struct_members = sms: struct List } = *type {
        return fprintf_s(out, "struct {\n") >= 0 &&
               display_struct_members(out, &sms) &&
               fprintf_s(out, "}%s%s", space, ident) >= 0;
    }
    if let Type::AnonUnion { struct_members = sms: struct List } = *type {
        return fprintf_s(out, "union {\n") >= 0 &&
               display_struct_members(out, &sms) &&
               fprintf_s(out, "}%s%s", space, ident) >= 0;
    }
    if let Type::AnonEnum { enum_members = ems: struct List } = *type {
        return fprintf_s(out, "enum {\n") >= 0 &&
               display_enum_members(out, &ems) &&
               fprintf_s(out, "}%s%s", space, ident) >= 0;
    }
    todo;
    return false;
}

fn display_type(out: FILE *, type: data Type *) -> bool
{
    return display_typed_identifier(out, type, "");
}

fn display_struct_members(out: FILE *, list: struct List *) -> bool
{
    let node: struct ListNode * = list->first;

    while (node)
    {
        let sm: struct StructMember * = (struct StructMember *)node->value;

        let result: bool = fprintf_s(out, "    ") >= 0 &&
                           display_typed_identifier(out, sm->type, sm->field) &&
                           fprintf_s(out, ";\n", sm->field) >= 0;

        if (!(result))
            return false;

        node = node->next;
    }

    return true;
}

fn display_enum_members(out: FILE *, list: struct List *) -> bool
{
    let node: struct ListNode * = list->first;

    while (node)
    {
        let enum_constant_name: char * = (char *)node->value;
        let result: bool = fprintf_s(out, "    %s,\n", enum_constant_name) >= 0;

        if (!result)
            return false;

        node = node->next;
    }
    return true;
}

// type ::= direct_type '*'*
fn parse_type(lxr: struct Lexer *) -> data Type *
{
    let type: data Type *;

    if (!(type = parse_direct_type(lxr)))
        return NULL;

    while (lexer_accept(lxr, TOK_STAR))
    {
        let new_type: data Type * = malloc(sizeof(*new_type));
        *new_type = Type::Ptr { child: type };
        type = new_type;
    }
    return type;
}

// direct_type ::= 'void'
//               | 'int'
//               | 'char'
//               | 'bool'
//               | 'cstr_arr' /* Temporary! */
//               | named_struct_ref
//               | named_enum_ref
//               | anonymous_struct_or_union
//               | anonymous_enum
//               | fn_ptr_type
// named_struct_ref ::= 'struct' 'ident'
// named_enum_ref ::= 'enum' 'ident'
// anonymous_struct_or_union ::= ('struct' | 'union') '{' struct_member_list '}'
// anonymous_enum ::= 'enum' '{' enumerator_list '}'
// fn_ptr_type ::= 'fn' '(' param_types ')' ('->' type)?
fn parse_direct_type(lxr: struct Lexer *) -> data Type *
{
    let type: data Type *;

    if (lexer_accept(lxr, TOK_VOID) ||
        lexer_accept(lxr, TOK_CHAR) ||
        lexer_accept(lxr, TOK_INT) ||
        lexer_accept(lxr, TOK_BOOL) ||
        lexer_accept(lxr, TOK_CSTR_ARR) ||
        lexer_accept(lxr, TOK_FILE))
    {
        type = malloc(sizeof(*type));

        switch (lxr->tok_tag)
        {
        case TOK_VOID:
            *type = Type::Void { _: 'x' };
            break;
        case TOK_CHAR:
            *type = Type::Char { _: 'x' };
            break;
        case TOK_INT:
            *type = Type::Int { _: 'x' };
            break;
        case TOK_BOOL:
            *type = Type::Bool { _: 'x' };
            break;
        case TOK_CSTR_ARR:
            *type = Type::CStrArr { _: 'x' };
            break;
        case TOK_FILE:
            *type = Type::File { _: 'x' };
            break;

        default:
            fprintf_s(stderr, "Unknown Type token %s\n", tok_tag_names[lxr->tok_tag]);
            exit(1);
        }

        return type;
    }

    if (lexer_accept(lxr, TOK_STRUCT))
    {
        // NAMED STRUCT REF
        if (lexer_accept(lxr, TOK_IDENT))
        {
            type = malloc(sizeof(*type));
            *type = Type::NamedStructRef { name: lxr->token };
            return type;
        }

        // ANON STRUCT
        if (lexer_expect(lxr, TOK_OPEN_BRACE))
        {
            let members: struct List = parse_struct_member_list(lxr);
            lexer_expect(lxr, TOK_CLOSE_BRACE);

            type = malloc(sizeof(*type));
            *type = Type::AnonStruct { struct_members: members };
            return type;
        }

        return NULL; // Unreachable.
    }

    if (lexer_accept(lxr, TOK_ENUM))
    {
        if (lexer_accept(lxr, TOK_IDENT))
        {
            type = malloc(sizeof(*type));
            *type = Type::NamedEnumRef { name: lxr->token };
            return type;
        }

        if (lexer_expect(lxr, TOK_OPEN_BRACE))
        {
            let members: struct List = parse_enumerator_list(lxr);
            lexer_expect(lxr, TOK_CLOSE_BRACE);

            type = malloc(sizeof(*type));
            *type = Type::AnonEnum { enum_members: members };
            return type;
        }

        return NULL; // Unreachable.
    }

    if (lexer_accept(lxr, TOK_DATA))
    {
        lexer_expect(lxr, TOK_IDENT);
        type = malloc(sizeof(*type));
        *type = Type::NamedDataRef { name: lxr->token };
        return type;
    }

    // ANON UNION
    if (lexer_accept(lxr, TOK_UNION))
    {
        lexer_expect(lxr, TOK_OPEN_BRACE);
        let members: struct List = parse_struct_member_list(lxr);
        lexer_expect(lxr, TOK_CLOSE_BRACE);

        type = malloc(sizeof(*type));
        *type = Type::AnonUnion { struct_members: members };
        return type;
    }

    // FUNTION POINTER TYPES
    if (lexer_accept(lxr, TOK_FN))
    {
        let ret_type: data Type * = NULL;
        lexer_expect(lxr, TOK_OPEN_PAREN);
        let param_types: struct List = parse_param_types(lxr);
        lexer_expect(lxr, TOK_CLOSE_PAREN);

        // Parse the optional return type.
        if (lexer_accept(lxr, TOK_ARROW))
        {
            if (!(ret_type = parse_type(lxr)))
            {
                fprintf_s(stderr, "PARSE ERROR at %s:%d\n", lxr->filename, lxr->line);
                fprintf_s(stderr, "| Could not parse a return type after `->`.\n");
                exit(1);
            }
        }

        type = malloc(sizeof(*type));
        *type = Type::FnPtr { param_types: param_types, ret_type: ret_type };
        return type;
    }

    return NULL;
}

// #-------------------------------------------------------------------------
// #  Items
// #-------------------------------------------------------------------------

struct ConstantExpr
{
    tag: enum {
        CONST_INT,
        CONST_BOOL,
        CONST_CSTR,
        CONST_ARRAY,
        CONST_IDENT,
    },

    as: union {
        const_int: int,
        const_bool: bool,
        const_cstr: char *,
        const_array: struct List, // A `List` of `ConstExpr*`s.
        const_ident: char *,
    },
}

fn display_const_array(out: FILE *, list: struct List *) -> bool
{
    let node: struct ListNode * = list->first;

    while (node)
    {
        let expr: struct ConstantExpr * = (struct ConstantExpr *)node->value;

        if (node->next)
        {
            let result: bool = display_constant_expr(out, expr) &&
                               fprintf_s(out, ",\n") >= 0;
            if (!result)
                return false;
        }
        else
        {
            let result: bool = display_constant_expr(out, expr) &&
                               fprintf_s(out, "\n") >= 0;
            if (!result)
                return false;
        }

        node = node->next;
    }
    return true;
}

fn display_constant_expr(out: FILE *, expr: struct ConstantExpr *) -> bool
{
    switch (expr->tag)
    {
    case CONST_INT:
        return fprintf_s(out, "%d", expr->as.const_int) >= 0;
    case CONST_BOOL:
        if (expr->as.const_bool)
            return fprintf_s(out, "true") >= 0;
        else
            return fprintf_s(out, "false") >= 0;
    case CONST_CSTR:
        return fprintf_s(out, "\"%s\"", expr->as.const_cstr) >= 0;
    case CONST_ARRAY:
        return fprintf_s(out, "{\n") >= 0 &&
               display_const_array(out, &expr->as.const_array) &&
               fprintf_s(out, "}") >= 0;
    case CONST_IDENT:
        return fprintf_s(out, "%s", expr->as.const_ident) >= 0;
    }
}

fn parse_initializer_list(lxr: struct Lexer *) -> struct List
{
    let initializers: struct List = list_init();
    let expr: struct ConstantExpr *;

    while ((expr = parse_constant_expr(lxr)))
    {
        if (!lexer_accept(lxr, TOK_COMMA))
            break;

        list_push(&initializers, expr);
    }

    return initializers;
}

fn parse_constant_expr(lxr: struct Lexer *) -> struct ConstantExpr *
{
    let expr: struct ConstantExpr *;

    if (lexer_accept(lxr, TOK_LITERAL_INT))
    {
        expr = malloc(sizeof(*expr));
        expr->tag = CONST_INT;
        expr->as.const_int = atoi(lxr->token);
        return expr;
    }

    if (lexer_accept(lxr, TOK_TRUE) || lexer_accept(lxr, TOK_FALSE))
    {
        let value: bool = lxr->tok_tag == TOK_TRUE;

        expr = malloc(sizeof(*expr));
        expr->tag = CONST_BOOL;
        expr->as.const_bool = value;
        return expr;
    }

    if (lexer_accept(lxr, TOK_LITERAL_STRING))
    {
        expr = malloc(sizeof(*expr));
        expr->tag = CONST_CSTR;
        expr->as.const_cstr = lxr->token;
        return expr;
    }

    if (lexer_accept(lxr, TOK_OPEN_BRACE))
    {
        let initializers: struct List = parse_initializer_list(lxr);
        lexer_expect(lxr, TOK_CLOSE_BRACE);

        expr = malloc(sizeof(*expr));
        expr->tag = CONST_ARRAY;
        expr->as.const_array = initializers;
        return expr;
    }

    if (lexer_accept(lxr, TOK_IDENT))
    {
        expr = malloc(sizeof(*expr));
        expr->tag = CONST_IDENT;
        expr->as.const_ident = lxr->token;
        return expr;
    }

    return NULL;
}

struct Item
{
    tag: enum {
        ITEM_FN_DEF,
        ITEM_GLOBAL_DECL,
        ITEM_NAMED_STRUCT_DECL,
        ITEM_NAMED_ENUM_DECL,
        ITEM_NAMED_DATA_DECL,
        ITEM_POUND_INCLUDE,
    },

    as: union {
        fn_def: struct {
            name: char *,
            params: struct List, // A `List` of `Parameter*`s.
            ret_type: struct Type *,
            body_stmts: struct List, // A `List` of `Stmt*`s.
        },

        global_decl: struct {
            type: struct Type *,
            name: char *,
            initializer: struct ConstantExpr *,
        },

        named_struct_decl: struct {
            name: char *,
            members: struct List, // A `List` of `StructMember`s.
        },

        named_enum_decl: struct {
            name: char *,
            members: struct List, // A `List` of `char*`s.
        },

        named_data_decl: struct {
            name: char *,
            members: struct List, // A `List` of `DataMember*`s.
        },

        pound_include: struct {
            filename: char *,
            kind: enum {
                POUND_INCLUDE_ANGLE_BRACKETS,
                POUND_INCLUDE_DOUBLE_QUOTES,
            },
        },

    },
}

// Expects a `List` of `Type *`s.
fn display_param_types(out: FILE *, param_types: struct List *) -> bool
{
    let node: struct ListNode * = param_types->first;

    while (node)
    {
        let type: struct Type * = (struct Type *)node->value;

        if (node->next)
        {
            let result: bool = display_type(out, type) &&
                               fprintf_s(out, ", ");
            if (!result)
                return false;
        }
        else
        {
            let result: bool = display_type(out, type);
            if (!result)
                return false;
        }

        node = node->next;
    }

    return true;
}

struct FnParam
{
    type: struct Type *,
    name: char *,
}

// Expects a `List` of `FnParam *`s.
fn display_fn_params(out: FILE *, params: struct List *) ->  bool
{
    let node: struct ListNode * = params->first;

    while (node)
    {
        let param: struct FnParam * = (struct FnParam *)node->value;

        if (node->next)
        {
            let result: bool = display_typed_identifier(out, param->type, param->name) &&
                               fprintf_s(out, ", ") >= 0;
            if (!result)
                return false;
        }
        else
        {
            let result: bool = display_typed_identifier(out, param->type, param->name);
            if (!result)
                return false;
        }

        node = node->next;
    }

    return true;
}

fn display_item(out: FILE *, item: struct Item *) -> bool
{
    switch (item->tag)
    {
    case ITEM_FN_DEF:
        return display_fn_signature(out, item->as.fn_def.name,
                                    &item->as.fn_def.params,
                                    item->as.fn_def.ret_type) &&
               fprintf_s(out, "\n{\n") >= 0 &&
               display_stmt_list(out, &item->as.fn_def.body_stmts) &&
               fprintf_s(out, "}\n\n") >= 0;
    case ITEM_GLOBAL_DECL:
        return display_type(out, item->as.global_decl.type) &&
               fprintf_s(out, " %s = ", item->as.global_decl.name) >= 0 &&
               display_constant_expr(out, item->as.global_decl.initializer) &&
               fprintf_s(out, ";\n\n") >= 0;
    case ITEM_NAMED_STRUCT_DECL:
        return fprintf_s(out, "struct %s {\n", item->as.named_struct_decl.name) >= 0 &&
               display_struct_members(out, &item->as.named_struct_decl.members) &&
               fprintf_s(out, "};\n\n") >= 0;
    case ITEM_NAMED_ENUM_DECL:
        return fprintf_s(out, "enum %s {\n", item->as.named_enum_decl.name) >= 0 &&
               display_enum_members(out, &item->as.named_enum_decl.members) &&
               fprintf_s(out, "};\n\n") >= 0;
    case ITEM_NAMED_DATA_DECL:
        return display_named_data_decl(out, item->as.named_data_decl.name, &item->as.named_data_decl.members);
    case ITEM_POUND_INCLUDE:
        if (item->as.pound_include.kind == POUND_INCLUDE_ANGLE_BRACKETS)
        {
            return fprintf_s(out, "#include <%s>\n", item->as.pound_include.filename) >= 0;
        }
        else
        {
            return fprintf_s(out, "#include \"%s\"\n", item->as.pound_include.filename) >= 0;
        }
    }
}

global PARAC_PREFIX: char * = "P8C";

fn mangle_variant_tag_name(type_name: char *, variant_name: char *) -> char *
{
    return format_alloc("%s__%s__TAG__%s", PARAC_PREFIX, type_name, variant_name);
}

fn mangle_variant_struct_name(type_name: char *, variant_name: char *) -> char *
{
    return format_alloc("%s__%s__AS__%s", PARAC_PREFIX, type_name, variant_name);
}

// Compiles an algebraic `data` type into the following type of struct:
//
// struct <name> {
//     tag: enum {
//          ...
//     },
//     as: union {
//         data1: struct { ... },
//         ...
//     },
// }
fn display_named_data_decl(out: FILE*, name: char *, members: struct List *) -> bool
{
    // A `List` of `StructMember`s.
    let struct_components: struct List = list_init();
    
    {
        let tags: struct List = list_init(); // A list of `char*`s.
        
        let iter: struct ListNode * = members->first;
        while (iter) {
            let dm: struct DataMember * = (struct DataMember *) iter->value;

            let mangled_name: char* = mangle_variant_tag_name(name, dm->name);
            list_push(&tags, (void *) mangled_name);

            iter = iter->next;
        }

        let tags_enum: data Type * = malloc(sizeof(*tags_enum));
        *tags_enum = Type::AnonEnum { enum_members: tags };

        {
            let enum_component: struct StructMember * = malloc(sizeof(*enum_component));
            enum_component->field = "tag";
            enum_component->type = tags_enum;
            list_push(&struct_components, (void *) enum_component);
        }
    }

    {
        let struct_members: struct List = list_init(); // a list of `StructMember`s.

        let iter: struct ListNode * = members->first;
        while (iter) {
            let dm: struct DataMember * = (struct DataMember *) iter->value;

            // If there's no data associated with the variant, don't add it to the union
            // of structs.
            if (!list_is_empty(&dm->struct_members))
            {
                let anon_struct: data Type * = malloc(sizeof(*anon_struct));
                *anon_struct = Type::AnonStruct { struct_members: dm->struct_members };

                let sm: struct StructMember * = malloc(sizeof(*sm));
                sm->field = mangle_variant_struct_name(name, dm->name);
                sm->type = anon_struct;

                list_push(&struct_members, (void *) sm);
            }

            iter = iter->next;
        }

        {
            let union_of_structs: data Type * = malloc(sizeof(*union_of_structs));
            *union_of_structs = Type::AnonUnion { struct_members: struct_members };

            let union_member: struct StructMember * = malloc(sizeof(*union_member));
            union_member->field = "as";
            union_member->type = union_of_structs;

            list_push(&struct_components, (void *) union_member);
        }
    }

    let struct_decl: struct Item * = malloc(sizeof(*struct_decl));
    struct_decl->tag = ITEM_NAMED_STRUCT_DECL;
    struct_decl->as.named_struct_decl.name = name;
    struct_decl->as.named_struct_decl.members = struct_components;

    return display_item(out, struct_decl);
}

// unnamed_parameter_list ::= type (',' type)* ','?
fn parse_param_types(lxr: struct Lexer *) -> struct List
{
    let types: struct List = list_init();
    let type: data Type *;

    while ((type = parse_type(lxr)))
    {
        list_push(&types, type);
        if (!lexer_accept(lxr, TOK_COMMA))
            break;
    }

    return types;
}

// parameter_list ::= type 'ident' (',' 'ident' ':' type)* ','?
fn parse_parameters(lxr: struct Lexer *) -> struct List
{
    let params: struct List = list_init();

    while (lexer_accept(lxr, TOK_IDENT))
    {
        let name: char * = lxr->token;

        lexer_expect(lxr, TOK_COLON);

        let type: struct Type *;
        if (!(type = parse_type(lxr)))
            todo; // TODO: report error

        let param: struct FnParam * = malloc(sizeof(*param));
        param->name = name;
        param->type = type;

        list_push(&params, (void *)param);

        if (!lexer_accept(lxr, TOK_COMMA))
            break;
    }

    return params;
}

global NEXT_TU_ID: int = 1000;

struct TranslationUnit
{
    id: int,                   // A unique ID associated with the translation unit.
    directives: struct List,   // A `List` of `Item*`s.
    enum_defns: struct List,   // A `List` of `Item*`s.
    struct_defns: struct List, // A `List` of `Item*`s.
    global_defns: struct List, // A `List` of `Item*`s.
    fn_defns: struct List,     // A `List` of `Item*`s.
}

fn translation_unit_init() -> struct TranslationUnit
{
    let tu: struct TranslationUnit;
    tu.id = NEXT_TU_ID;
    NEXT_TU_ID = NEXT_TU_ID + 1;
    tu.directives = list_init();
    tu.enum_defns = list_init();
    tu.struct_defns = list_init();
    tu.global_defns = list_init();
    tu.fn_defns = list_init();
    return tu;
}

fn translation_unit_push_item(tu: struct TranslationUnit *, item: struct Item *)
{
    switch (item->tag)
    {
    case ITEM_POUND_INCLUDE:
        list_push(&tu->directives, item);
        return;

    case ITEM_NAMED_ENUM_DECL:
        list_push(&tu->enum_defns, item);
        return;

    case ITEM_NAMED_STRUCT_DECL:
    case ITEM_NAMED_DATA_DECL:
        list_push(&tu->struct_defns, item);
        return;

    case ITEM_GLOBAL_DECL:
        list_push(&tu->global_defns, item);
        return;

    case ITEM_FN_DEF:
        list_push(&tu->fn_defns, item);
        return;
    }
}

// translation_unit ::= item*
fn parse_translation_unit(lxr: struct Lexer *) -> struct TranslationUnit
{
    let tu: struct TranslationUnit = translation_unit_init();
    let item: struct Item *;

    while ((item = parse_item(lxr)))
        translation_unit_push_item(&tu, item);

    lexer_expect(lxr, TOK_END_OF_INPUT);

    return tu;
}

fn display_item_list(out: FILE *, items: struct List *) -> bool
{
    let node: struct ListNode * = items->first;
    while (node)
    {
        let item: struct Item * = (struct Item *)node->value;

        if (!display_item(out, item))
            return false;

        node = node->next;
    }
    return true;
}

fn display_tu_struct_decls(out: FILE *, tu: struct TranslationUnit *) -> bool
{
    let node: struct ListNode * = tu->struct_defns.first;
    while (node)
    {
        let item: struct Item * = (struct Item *)node->value;

        if (item->tag == ITEM_NAMED_STRUCT_DECL)
        {
            if (!(fprintf_s(out, "struct %s;\n", item->as.named_struct_decl.name) >= 0))
                return false;
        }
        else if (item->tag == ITEM_NAMED_DATA_DECL)
        {
            if (!(fprintf_s(out, "struct %s;\n", item->as.named_data_decl.name) >= 0))
                return false;
        }
        else
            todo;

        node = node->next;
    }
    return true;
}

fn display_tu_fn_decls(out: FILE *, tu: struct TranslationUnit *) -> bool
{
    let node: struct ListNode * = tu->fn_defns.first;
    while (node)
    {
        let item: struct Item * = (struct Item *)node->value;

        if (item->tag != ITEM_FN_DEF)
            todo;

        if (!(display_fn_signature(out, item->as.fn_def.name, &item->as.fn_def.params,
                                   item->as.fn_def.ret_type) &&
              fprintf_s(out, ";\n") >= 0))
            return false;

        node = node->next;
    }
    return true;
}

fn display_translation_unit(out: FILE *, tu: struct TranslationUnit *) -> bool
{
    return fprintf_s(out, "#ifndef PARASITIC_C_FILE__%X\n", tu->id) >= 0 &&
           fprintf_s(out, "#define PARASITIC_C_FILE__%X\n", tu->id) >= 0 &&

           fprintf_s(out, "\n// DIRECTIVES //\n") >= 0 &&
           display_item_list(out, &tu->directives) &&

           fprintf_s(out, "\n// STRUCT DECLS //\n") >= 0 &&
           display_tu_struct_decls(out, tu) &&

           fprintf_s(out, "\n// ENUM DEFNS //\n") >= 0 &&
           display_item_list(out, &tu->enum_defns) &&

           fprintf_s(out, "\n// STRUCT DEFNS //\n") >= 0 &&
           display_item_list(out, &tu->struct_defns) &&

           fprintf_s(out, "\n// GLOBAL DEFNS //\n") >= 0 &&
           display_item_list(out, &tu->global_defns) &&

           fprintf_s(out, "\n// FN DECLS //\n") >= 0 &&
           display_tu_fn_decls(out, tu) &&

           fprintf_s(out, "\n// FN DEFNS //\n") >= 0 &&
           display_item_list(out, &tu->fn_defns) &&

           fprintf_s(out, "\n#endif // PARASITIC_C_FILE__%X\n", tu->id);
}

// item ::= function_def
//        | global_def
//        | named_struct_or_union_decl
//        | named_enum_decl
//        | compiler_directive
fn parse_item(lxr: struct Lexer *) -> struct Item *
{
    let item: struct Item *;

    // function_def ::= 'fn' 'ident' '(' parameter_list? ')' ('->' type)? stmt_block
    if (lexer_accept(lxr, TOK_FN))
    {
        lexer_expect(lxr, TOK_IDENT);
        let name: char * = lxr->token;
        lexer_expect(lxr, TOK_OPEN_PAREN);
        let param_types: struct List = parse_parameters(lxr);
        lexer_expect(lxr, TOK_CLOSE_PAREN);

        let ret_type: struct Type *;
        if (lexer_accept(lxr, TOK_ARROW))
        {
            ret_type = parse_type(lxr);
        }
        else
        {
            ret_type = malloc(sizeof(*ret_type));
            *ret_type = Type::Void { _: 'x' };
        }

        lexer_expect(lxr, TOK_OPEN_BRACE);
        let body_stmts: struct List = parse_stmt_list(lxr);
        lexer_expect(lxr, TOK_CLOSE_BRACE);

        item = malloc(sizeof(*item));
        item->tag = ITEM_FN_DEF;
        item->as.fn_def.name = name;
        item->as.fn_def.params = param_types;
        item->as.fn_def.ret_type = ret_type;
        item->as.fn_def.body_stmts = body_stmts;

        return item;
    }

    // GLOBAL VARIABLE DEFINITION
    // global_def ::= 'global' 'ident' ':' type '=' constant_expr ';'
    if (lexer_accept(lxr, TOK_GLOBAL))
    {
        lexer_expect(lxr, TOK_IDENT);
        let name: char * = lxr->token;

        lexer_expect(lxr, TOK_COLON);

        let type: struct Type *;
        if (!(type = parse_type(lxr)))
            todo; // Report error

        lexer_expect(lxr, TOK_EQUAL);

        let initializer: struct ConstantExpr *;
        if (!(initializer = parse_constant_expr(lxr)))
            todo; // Report error

        lexer_expect(lxr, TOK_SEMI);

        item = malloc(sizeof(*item));
        item->tag = ITEM_GLOBAL_DECL;
        item->as.global_decl.type = type;
        item->as.global_decl.name = name;
        item->as.global_decl.initializer = initializer;

        return item;
    }

    // STRUCT DEFINITION
    // named_struct_decl ::= 'struct' 'ident' '{' struct_member+ '}'
    if (lexer_accept(lxr, TOK_STRUCT))
    {
        lexer_expect(lxr, TOK_IDENT);
        let name: char * = lxr->token;
        lexer_expect(lxr, TOK_OPEN_BRACE);
        let members: struct List = parse_struct_member_list(lxr);
        lexer_expect(lxr, TOK_CLOSE_BRACE);
        if (lexer_accept(lxr, TOK_SEMI))
        {
            fprintf_s(stderr, "[WARNING] %s:%d:\n", lxr->filename, lxr->line);
            fprintf_s(stderr, "    A semicolon is no longer needed after a struct definition.\n");
        }

        let item: struct Item * = malloc(sizeof(*item));
        item->tag = ITEM_NAMED_STRUCT_DECL;
        item->as.named_struct_decl.name = name;
        item->as.named_struct_decl.members = members;

        return item;
    }

    // ENUM DEFINITION
    // named_enum_decl ::= 'enum' 'ident' '{' enumerator_list '}'
    if (lexer_accept(lxr, TOK_ENUM))
    {
        lexer_expect(lxr, TOK_IDENT);
        let name: char * = lxr->token;
        lexer_expect(lxr, TOK_OPEN_BRACE);
        let members: struct List = parse_enumerator_list(lxr);
        lexer_expect(lxr, TOK_CLOSE_BRACE);
        if (lexer_accept(lxr, TOK_SEMI))
        {
            fprintf_s(stderr, "[WARNING] %s:%d:\n", lxr->filename, lxr->line);
            fprintf_s(stderr, "    A semicolon is no longer needed after an enum definition.\n");
        }

        let item: struct Item * = malloc(sizeof(*item));
        item->tag = ITEM_NAMED_ENUM_DECL;
        item->as.named_enum_decl.name = name;
        item->as.named_enum_decl.members = members;

        return item;
    }

    // DATA DEFINITION
    if (lexer_accept(lxr, TOK_DATA))
    {
        lexer_expect(lxr, TOK_IDENT);
        let name: char * = lxr->token;
        lexer_expect(lxr, TOK_OPEN_BRACE);
        let members: struct List = parse_data_member_list(lxr);
        lexer_expect(lxr, TOK_CLOSE_BRACE);
        if (lexer_accept(lxr, TOK_SEMI))
        {
            fprintf_s(stderr, "[WARNING] %s:%d:\n", lxr->filename, lxr->line);
            fprintf_s(stderr, "    A semicolon is not needed after a data definition.\n");
        }

        let item: struct Item * = malloc(sizeof(*item));
        item->tag = ITEM_NAMED_DATA_DECL;
        item->as.named_data_decl.name = name;
        item->as.named_data_decl.members = members;

        return item;
    }

    // COMPILER DIRECTIVE
    // compiler_directive ::= '#' 'include' (angle_bracket_filename | double_quoted_filename)
    if (lexer_accept(lxr, TOK_POUND))
    {
        lexer_expect(lxr, TOK_INCLUDE);

        let kind: int;
        if (lexer_accept(lxr, TOK_ANGLE_BRACK_FILENAME))
            kind = (int)POUND_INCLUDE_ANGLE_BRACKETS;
        else if (lexer_accept(lxr, TOK_LITERAL_STRING))
            kind = (int)POUND_INCLUDE_DOUBLE_QUOTES;
        else
            return NULL;

        item = malloc(sizeof(*item));
        item->tag = ITEM_POUND_INCLUDE;
        item->as.pound_include.filename = lxr->token;
        item->as.pound_include.kind = kind;

        return item;
    }

    return NULL;
}

// initializer_list ::= '{' '}' | '{' constant_expr (',' constant_expr )* ','? '}'

// enumerator_list ::= <empty string>
//                   | 'ident' (',' 'ident')* ','?
fn parse_enumerator_list(lxr: struct Lexer *) -> struct List
{
    let members: struct List = list_init();
    let member: char *;

    while (lexer_accept(lxr, TOK_IDENT))
    {
        member = lxr->token;
        list_push(&members, (void *)member);

        if (!lexer_accept(lxr, TOK_COMMA))
            return members;
    }

    return members;
}

struct DataMember {
    name: char*,
    struct_members: struct List, // A `List` of `StructMember*`s.
}

// data_member_list ::= data_member*
// data_member ::= 'ident' '{' struct_member_list '}' ','
fn parse_data_member_list(lxr: struct Lexer *) -> struct List
{
    let list: struct List = list_init();

    while (lexer_accept(lxr, TOK_IDENT))
    {
        let variant_name: char * = lxr->token;

        let struct_members: struct List = list_init();

        // Allow optional brace-delimited list of members. An empty brace list is the same
        // as no brace list, i.e. `A::X {}` == `A::X`.
        if (lexer_accept(lxr, TOK_OPEN_BRACE))
        {
            while (lexer_accept(lxr, TOK_IDENT))
            {
                let field: char * = lxr->token;

                lexer_expect(lxr, TOK_COLON);

                let type: struct Type *;
                if (!(type = parse_type(lxr)))
                    todo; // TODO: report error

                let sm: struct StructMember * = malloc(sizeof(*sm));
                sm->field = field;
                sm->type = type;

                list_push(&struct_members, (void *)sm);

                if (!lexer_accept(lxr, TOK_COMMA))
                    break;
            }

            lexer_expect(lxr, TOK_CLOSE_BRACE);
        }


        let dm: struct DataMember * = malloc(sizeof(*dm));
        dm->name = variant_name;
        dm->struct_members = struct_members;

        list_push(&list, (void *)dm);

        if (!lexer_accept(lxr, TOK_COMMA))
            break;
    }

    return list;
}

// #-------------------------------------------------------------------------
// #  A.2.3  Statements
// #-------------------------------------------------------------------------

struct Stmt {
    tag: enum {
        STMT_BLOCK,
        STMT_IF,
        STMT_WHILE,
        STMT_SWITCH,
        STMT_BREAK,
        STMT_CONTINUE,
        STMT_RETURN,
        STMT_VAR_DECL,
        STMT_IF_LET,
        STMT_LET_ELSE,
        STMT_EXPRESSION,
    },

    as: union {
        if_stmt: struct {
            cond: struct Expr *,
            consequent: struct Stmt *,
            alternative: struct Stmt *, // Nullable ptr.
        },

        while_stmt: struct {
            cond: struct Expr *,
            body: struct Stmt *,
        },

        switch_stmt: struct {
            scrutinee: struct Expr *,
            switch_arms: struct List, // A `List` of `SwitchArm*`s.
        },

        block: struct {
            stmts: struct List, // A `List` of `Stmt*`s
        },

        ret: struct {
            expr: struct Expr *, // Nullable ptr.
        },

        var_decl: struct {
            type: struct Type *,
            name: char *,
            initializer: struct Expr *, // Nullable ptr.
        },

        if_let: struct {
            type_name: char *,
            variant_name: char *,
            bindings: struct List, // A `List` of `BindingTriple *`s.
            expr: struct Expr *,
            consequent: struct Stmt *,
            alternative: struct Stmt *, // Nullable pointer!
        },

        let_else: struct {
            type_name: char *,
            variant_name: char *,
            bindings: struct List, // A `List` of `BindingTriple *`s.
            expr: struct Expr *,
            alternative: struct Stmt *,
        },

        expression: struct {
            expr: struct Expr *,
        },

    },
}

struct SwitchArm {
    test: struct Expr *, // Nullable. NULL indicates `default` arm.
    stmts: struct List, // A `List` of `Stmts*`s.
}

struct BindingTriple {
    field: char *,
    binder: char *,
    type: struct Type *,
}

fn display_switch_arms(out: FILE *, arms: struct List *) -> bool
{
    let node: struct ListNode * = arms->first;

    while (node)
    {
        let arm: struct SwitchArm * = (struct SwitchArm *)node->value;

        // If `test` is NULL, this is a `default` arm.
        if (arm->test == NULL)
        {
            // We're inserting braces around the stmts in the arm so that variable
            // declarations don't collide.
            let result: bool = fprintf_s(out, "default:\n") >= 0 &&
                               fprintf_s(out, "{\n") >= 0 &&
                               display_stmt_list(out, &arm->stmts) &&
                               fprintf_s(out, "}\n") >= 0;
            if (!result)
                return false;
        }
        else
        {
            // We're inserting braces around the stmts in the arm so that variable
            // declarations don't collide.
            let result: bool = fprintf_s(out, "case ") >= 0 &&
                               display_expr(out, arm->test) &&
                               fprintf_s(out, ":\n") >= 0 &&
                               fprintf_s(out, "{\n") >= 0 &&
                               display_stmt_list(out, &arm->stmts) &&
                               fprintf_s(out, "}\n") >= 0;
            if (!result)
                return false;
        }

        node = node->next;
    }

    return true;
}

fn display_stmt(out: FILE *, stmt: struct Stmt *) -> bool
{
    switch (stmt->tag)
    {
    case STMT_BLOCK:
        return fprintf_s(out, "{\n") >= 0 &&
               display_stmt_list(out, &stmt->as.block.stmts) &&
               fprintf_s(out, "}\n") >= 0;
    case STMT_IF:
        if (stmt->as.if_stmt.alternative)
        {
            return fprintf_s(out, "if (") >= 0 &&
                   display_expr(out, stmt->as.if_stmt.cond) &&
                   fprintf_s(out, ")\n") >= 0 &&
                   display_stmt(out, stmt->as.if_stmt.consequent) &&
                   fprintf_s(out, "else\n") >= 0 &&
                   display_stmt(out, stmt->as.if_stmt.alternative);
        }
        else
        {
            return fprintf_s(out, "if (") >= 0 &&
                   display_expr(out, stmt->as.if_stmt.cond) &&
                   fprintf_s(out, ")\n") >= 0 &&
                   display_stmt(out, stmt->as.if_stmt.consequent);
        }
    case STMT_WHILE:
        return fprintf_s(out, "while (") >= 0 &&
               display_expr(out, stmt->as.while_stmt.cond) &&
               fprintf_s(out, ")\n") >= 0 &&
               display_stmt(out, stmt->as.while_stmt.body);
    case STMT_SWITCH:
        return fprintf_s(out, "switch (") >= 0 &&
               display_expr(out, stmt->as.switch_stmt.scrutinee) &&
               fprintf_s(out, ")\n{\n") >= 0 &&
               display_switch_arms(out, &stmt->as.switch_stmt.switch_arms) &&
               fprintf_s(out, "}\n") >= 0;
    case STMT_BREAK:
        return fprintf_s(out, "break;\n") >= 0;
    case STMT_CONTINUE:
        return fprintf_s(out, "continue;\n") >= 0;
    case STMT_RETURN:
        if (stmt->as.ret.expr)
        {
            return fprintf_s(out, "return ") >= 0 &&
                   display_expr(out, stmt->as.ret.expr) &&
                   fprintf_s(out, ";\n") >= 0;
        }
        else
        {
            return fprintf_s(out, "return;\n") >= 0;
        }
    case STMT_VAR_DECL:
        if (stmt->as.var_decl.initializer)
        {
            return display_typed_identifier(out, stmt->as.var_decl.type, stmt->as.var_decl.name) &&
                   fprintf_s(out, " = ") >= 0 &&
                   display_expr(out, stmt->as.var_decl.initializer) &&
                   fprintf_s(out, ";\n") >= 0;
        }
        else
        {
            return display_typed_identifier(out, stmt->as.var_decl.type, stmt->as.var_decl.name) &&
                   fprintf_s(out, ";\n", stmt->as.var_decl.name) >= 0;
        }
    case STMT_IF_LET:
        return display_if_let(out, stmt->as.if_let.type_name,
                                   stmt->as.if_let.variant_name,
                                   &stmt->as.if_let.bindings,
                                   stmt->as.if_let.expr,
                                   stmt->as.if_let.consequent,
                                   stmt->as.if_let.alternative);
    case STMT_LET_ELSE:
        return display_let_else(out, stmt->as.let_else.type_name,
                                     stmt->as.let_else.variant_name,
                                     &stmt->as.let_else.bindings,
                                     stmt->as.let_else.expr,
                                     stmt->as.let_else.alternative);
    case STMT_EXPRESSION:
        return display_expr(out, stmt->as.expression.expr) &&
               fprintf_s(out, ";\n") >= 0;
    }
}

fn display_stmt_list(out: FILE *, list: struct List *) -> bool
{
    let node: struct ListNode * = list->first;

    while (node)
    {
        let stmt: struct Stmt * = (struct Stmt *)node->value;
        let result: bool = display_stmt(out, stmt);

        if (!result)
            return false;

        node = node->next;
    }

    return true;
}

global TEMP_ID: int = 0;

fn gen_temp() -> char *
{
    let name: char * = format_alloc("%s__TEMP_%d", PARAC_PREFIX, TEMP_ID);
    TEMP_ID = TEMP_ID + 1;
    return name;
}

fn display_if_let(
    out: FILE *,
    type_name: char *,
    variant_name: char *,
    bindings: struct List *,
    expr: struct Expr *,
    consequent: struct Stmt *,
    alternative: struct Stmt *,
) -> bool
{
    let expr_temp: char * = gen_temp();

    let type: struct Type * = malloc(sizeof(*type));
    *type = Type::NamedDataRef { name: type_name };

    // Save `expr` in a temporary named `expr_temp`.
    if (!(display_typed_identifier(out, type, expr_temp) &&
          fprintf_s(out, " = ") >= 0 &&
          display_expr(out, expr) &&
          fprintf_s(out, ";\n") >= 0))
        return false;


    // First check that it is the expected variant.
    {
        let tag_name: char * = mangle_variant_tag_name(type_name, variant_name);
        if (!(fprintf_s(out, "if (%s.tag == %s) {", expr_temp, tag_name) >= 0))
            return false;
    }

    // If so, destructure the variant into bindings.
    let iter: struct ListNode * = bindings->first;
    while (iter)
    {
        let bt: struct BindingTriple * = (struct BindingTriple *) iter->value;

        if (!display_typed_identifier(out, bt->type, bt->binder))
            return false;

        let variant_struct_name: char * = mangle_variant_struct_name(type_name, variant_name);
        if (!(fprintf_s(out, " = %s.as.%s.%s;", expr_temp, variant_struct_name, bt->field) >= 0))
            return false;
        

        iter = iter->next;
    }

    // Perform the consequent statements.
    if (!display_stmt(out, consequent))
        return false;

    if (!(fprintf_s(out, "\n}") >= 0))
        return false;

    // If there is an alternative, add an `else` branch.
    if (alternative != NULL)
    {
        if (!(fprintf_s(out, " else {\n") >= 0))
            return false;

        if (!display_stmt(out, alternative))
            return false;

        if (!(fprintf_s(out, "}\n") >= 0))
            return false;
    }

    return true;
}

fn display_let_else(
    out: FILE *,
    type_name: char *,
    variant_name: char *,
    bindings: struct List *,
    expr: struct Expr *,
    alternative: struct Stmt *,
) -> bool
{
    let expr_temp: char * = gen_temp();

    let type: struct Type * = malloc(sizeof(*type));
    *type = Type::NamedDataRef { name: type_name };

    // Save `expr` in a temporary named `expr_temp`.
    if (!(display_typed_identifier(out, type, expr_temp) &&
          fprintf_s(out, " = ") >= 0 &&
          display_expr(out, expr) &&
          fprintf_s(out, ";\n") >= 0))
        return false;

    // First check that it is the expected variant.
    {
        let tag_name: char * = mangle_variant_tag_name(type_name, variant_name);
        if (!(fprintf_s(out, "if (%s.tag != %s)", expr_temp, tag_name) >= 0 &&
              display_stmt(out, alternative)))
            return false;
    }

    // Then destructure the variant into bindings.
    let iter: struct ListNode * = bindings->first;
    while (iter)
    {
        let bt: struct BindingTriple * = (struct BindingTriple *) iter->value;

        if (!display_typed_identifier(out, bt->type, bt->binder))
            return false;

        let variant_struct_name: char * = mangle_variant_struct_name(type_name, variant_name);
        if (!(fprintf_s(out, " = %s.as.%s.%s;", expr_temp, variant_struct_name, bt->field) >= 0))
            return false;
        

        iter = iter->next;
    }
    return true;
}

// stmt ::= stmt_block
//        | if_stmt
//        | while_stmt
//        | switch_stmt
//        | jump_stmt
//        | return_stmt
//        | var_decl
//        | expr_stmt
// stmt_block ::= '{' stmt_list '}'
// if_stmt ::= 'if' '(' expression ')' stmt ('else' stmt)?
// while_stmt ::= 'while' '(' expression ')' stmt
// switch_stmt ::= 'switch' '(' expression ')' '{' switch_arms '}'
// switch_arms ::= switch_arm*
// switch_arm ::= ( 'case' expression | 'default' ) ':' stmt*
// jump_stmt ::= ('break' | 'continue') ';'
// return_stmt ::= 'return' expression? ';'
// expr_stmt ::= expression ';'
fn parse_stmt(lxr: struct Lexer *) -> struct Stmt *
{
    let stmt: struct Stmt *;

    if (lexer_accept(lxr, TOK_OPEN_BRACE))
    {
        let stmts: struct List = parse_stmt_list(lxr);
        lexer_expect(lxr, TOK_CLOSE_BRACE);

        stmt = malloc(sizeof(*stmt));
        stmt->tag = STMT_BLOCK;
        stmt->as.block.stmts = stmts;

        return stmt;
    }

    if (lexer_accept(lxr, TOK_IF))
    {
        if (lexer_accept(lxr, TOK_LET))
        {
            // IF-LET STMT
            return parse_if_let_follow(lxr);
        } else {
            // IF STMT
            lexer_expect(lxr, TOK_OPEN_PAREN);
            let cond: struct Expr * = parse_expression(lxr);
            lexer_expect(lxr, TOK_CLOSE_PAREN);
            let consequent: struct Stmt * = parse_stmt(lxr);

            let alternative: struct Stmt * = NULL;
            if (lexer_accept(lxr, TOK_ELSE))
                if (!(alternative = parse_stmt(lxr)))
                    return NULL; // TODO: report error here

            stmt = malloc(sizeof(*stmt));
            stmt->tag = STMT_IF;
            stmt->as.if_stmt.cond = cond;
            stmt->as.if_stmt.consequent = consequent;
            stmt->as.if_stmt.alternative = alternative;

            return stmt;
        }
    }

    // WHILE STMT
    if (lexer_accept(lxr, TOK_WHILE))
    {
        lexer_expect(lxr, TOK_OPEN_PAREN);
        let cond: struct Expr * = parse_expression(lxr);
        lexer_expect(lxr, TOK_CLOSE_PAREN);
        let body: struct Stmt * = parse_stmt(lxr);

        stmt = malloc(sizeof(*stmt));
        stmt->tag = STMT_WHILE;
        stmt->as.while_stmt.cond = cond;
        stmt->as.while_stmt.body = body;

        return stmt;
    }

    // SWITCH STMT
    if (lexer_accept(lxr, TOK_SWITCH))
    {
        lexer_expect(lxr, TOK_OPEN_PAREN);
        let scrutinee: struct Expr * = parse_expression(lxr);
        lexer_expect(lxr, TOK_CLOSE_PAREN);
        lexer_expect(lxr, TOK_OPEN_BRACE);
        let arms: struct List = parse_switch_arms(lxr);
        lexer_expect(lxr, TOK_CLOSE_BRACE);

        stmt = malloc(sizeof(*stmt));
        stmt->tag = STMT_SWITCH;
        stmt->as.switch_stmt.scrutinee = scrutinee;
        stmt->as.switch_stmt.switch_arms = arms;

        return stmt;
    }

    // BREAK STMT
    if (lexer_accept(lxr, TOK_BREAK))
    {
        lexer_expect(lxr, TOK_SEMI);

        stmt = malloc(sizeof(*stmt));
        stmt->tag = STMT_BREAK;

        return stmt;
    }

    // CONTINUE STMT
    if (lexer_accept(lxr, TOK_CONTINUE))
    {
        lexer_expect(lxr, TOK_SEMI);

        stmt = malloc(sizeof(*stmt));
        stmt->tag = STMT_CONTINUE;

        return stmt;
    }

    // RETURN STMT
    if (lexer_accept(lxr, TOK_RETURN))
    {
        let expr: struct Expr * = NULL;
        expr = parse_expression(lxr);
        lexer_expect(lxr, TOK_SEMI);

        stmt = malloc(sizeof(*stmt));
        stmt->tag = STMT_RETURN;
        stmt->as.ret.expr = expr;

        return stmt;
    }

    if (lexer_accept(lxr, TOK_LET))
    {
        lexer_expect(lxr, TOK_IDENT);
        let ident: char * = lxr->token;

        if (lexer_accept(lxr, TOK_COLON))
        {
            // VARIABLE DECLARATION STMT
            return parse_var_decl_follow(lxr, ident);
        }

        if (lexer_accept(lxr, TOK_COLON_COLON))
        {
            // UNSAFE PATTERN DESTRUCT STMT
            return parse_let_else_follow(lxr, ident);
        }

        todo; // Report error.
    }

    // EXPRESSION STMT
    let expr: struct Expr *;
    if ((expr = parse_expression(lxr)))
    {
        lexer_expect(lxr, TOK_SEMI);

        stmt = malloc(sizeof(*stmt));
        stmt->tag = STMT_EXPRESSION;
        stmt->as.expression.expr = expr;

        return stmt;
    }

    return NULL;
}

// stmt_list ::= stmt*
fn parse_stmt_list(lxr: struct Lexer *) -> struct List
{
    let stmts: struct List = list_init();
    let stmt: struct Stmt *;

    while ((stmt = parse_stmt(lxr)))
        list_push(&stmts, (void *)stmt);

    return stmts;
}

// var_decl ::= 'let' 'ident' ':' type ('=' expression)? ';'
// Expects `let NAME:` to be parsed ahead of time!
fn parse_var_decl_follow(lxr: struct Lexer *, name: char *) -> struct Stmt *
{
    let type: struct Type *;
    if (!(type = parse_type(lxr)))
    {
        fprintf_s(stderr, "You must provide a type after a let binding!\n");
        exit(1);
    }

    let initializer: struct Expr * = NULL;

    if (lexer_accept(lxr, TOK_EQUAL))
    {
        if (!(initializer = parse_expression(lxr)))
            return NULL;
    }

    lexer_expect(lxr, TOK_SEMI);

    let stmt: struct Stmt * = malloc(sizeof(*stmt));
    stmt->tag = STMT_VAR_DECL;
    stmt->as.var_decl.name = name;
    stmt->as.var_decl.type = type;
    stmt->as.var_decl.initializer = initializer;

    return stmt;
}

// Parses: `{ x = my_x: int, y = my_y: int, ... }`
// Returns a `List` of `BindingTriple *`s.
fn parse_struct_pattern_bindings(lxr: struct Lexer *) -> struct List
{
    lexer_expect(lxr, TOK_OPEN_BRACE);

    let bindings: struct List = list_init();

    while (true)
    {
        if (!(lexer_accept(lxr, TOK_IDENT)))
            break;

        let field: char * = lxr->token;

        lexer_expect(lxr, TOK_EQUAL);
        lexer_expect(lxr, TOK_IDENT);
        let binder: char * = lxr->token;

        let filename: char * = lxr->filename;
        let line: int = lxr->line;
        let type: struct Type *;
        if (!(lexer_accept(lxr, TOK_COLON) &&
              (type = parse_type(lxr))))
        {
            fprintf_s(stderr, "PARSE_ERROR:\n| at %s:%d\n", filename, line);
            fprintf_s(stderr, "|\n");
            fprintf_s(stderr, "|  expected type annotation after pattern destructuring variable name\n");
            fprintf_s(stderr, "|\n");
            fprintf_s(stderr, "|> `%.20s`\n", lxr->old_input);
            exit(1);
        }

        let bt: struct BindingTriple * = malloc(sizeof(*bt));
        bt->field = field;
        bt->binder = binder;
        bt->type = type;

        list_push(&bindings, (void *) bt);

        if (!(lexer_accept(lxr, TOK_COMMA)))
            break;
    }

    lexer_expect(lxr, TOK_CLOSE_BRACE);

    return bindings;
}

fn parse_stmt_block(lxr: struct Lexer *) -> struct Stmt *
{
    lexer_expect(lxr, TOK_OPEN_BRACE);
    let stmts: struct List = parse_stmt_list(lxr);
    lexer_expect(lxr, TOK_CLOSE_BRACE);

    let block: struct Stmt * = malloc(sizeof(*block));
    block->tag = STMT_BLOCK;
    block->as.block.stmts = stmts;

    return block;
}

// `if let Expr::Add { x = my_x: int, y = my_y: int, } = e {
//      consequent...
//  } else {
//      alternative...
//  }`
// The else branch and alternative are optional.
// NOTE: Expects `if` and `let` to have been parsed already!
fn parse_if_let_follow(lxr: struct Lexer *) -> struct Stmt *
{
    lexer_expect(lxr, TOK_IDENT);
    let type_name: char * = lxr->token;

    lexer_expect(lxr, TOK_COLON_COLON);

    lexer_expect(lxr, TOK_IDENT);
    let variant_name: char * = lxr->token;

    let bindings: struct List = parse_struct_pattern_bindings(lxr);

    lexer_expect(lxr, TOK_EQUAL);

    let expr: struct Expr *;
    if (!(expr = parse_expression(lxr)))
        todo; // Report error.

    let consequent: struct Stmt * = parse_stmt_block(lxr);

    let alternative: struct Stmt * = NULL;
    if (lexer_accept(lxr, TOK_ELSE))
    {
        alternative = parse_stmt_block(lxr);
    }

    let stmt: struct Stmt * = malloc(sizeof(*stmt));
    stmt->tag = STMT_IF_LET;
    stmt->as.if_let.type_name = type_name;
    stmt->as.if_let.variant_name = variant_name;
    stmt->as.if_let.bindings = bindings;
    stmt->as.if_let.expr = expr;
    stmt->as.if_let.alternative = alternative;
    stmt->as.if_let.consequent = consequent;

    return stmt;
}

// `let Expr::Add { x = x: int, y = y: int, } = e else { stmts... }
// Expects `let TYPE_NAME::` to be parsed ahead of time!
fn parse_let_else_follow(lxr: struct Lexer *, type_name: char *) -> struct Stmt *
{
    lexer_expect(lxr, TOK_IDENT);
    let variant_name: char * = lxr->token;

    let bindings: struct List = parse_struct_pattern_bindings(lxr);

    lexer_expect(lxr, TOK_EQUAL);

    let expr: struct Expr *;
    if (!(expr = parse_expression(lxr)))
        todo; // Report error.

    lexer_expect(lxr, TOK_ELSE);

    let alternative: struct Stmt * = parse_stmt_block(lxr);

    let stmt: struct Stmt * = malloc(sizeof(*stmt));
    stmt->tag = STMT_LET_ELSE;
    stmt->as.let_else.type_name = type_name;
    stmt->as.let_else.variant_name = variant_name;
    stmt->as.let_else.bindings = bindings;
    stmt->as.let_else.expr = expr;
    stmt->as.let_else.alternative = alternative;

    return stmt;
}

fn parse_switch_arms(lxr: struct Lexer *) -> struct List
{
    let arms: struct List = list_init();

    while (lexer_accept(lxr, TOK_CASE) || lexer_accept(lxr, TOK_DEFAULT))
    {
        let arm: struct SwitchArm *;

        if (lxr->tok_tag == TOK_CASE)
        {
            let test: struct Expr *;

            if (!(test = parse_expression(lxr)))
                todo; // Report the error.

            lexer_expect(lxr, TOK_COLON);

            let stmts: struct List = parse_stmt_list(lxr);

            arm = malloc(sizeof(*arm));
            arm->test = test;
            arm->stmts = stmts;

            list_push(&arms, (void *)arm);
        }
        else if (lxr->tok_tag == TOK_DEFAULT)
        {
            lexer_expect(lxr, TOK_COLON);

            let stmts: struct List = parse_stmt_list(lxr);

            arm = malloc(sizeof(*arm));
            arm->test = NULL; // NULL indicates this is a `default` arm.
            arm->stmts = stmts;

            list_push(&arms, (void *)arm);
        }
    }

    return arms;
}

// #-------------------------------------------------------------------------
// #  A.2.1  Expressions
// #-------------------------------------------------------------------------

struct Expr {
    tag: enum {
        EXPR_LITERAL_INT,
        EXPR_LITERAL_CHAR,
        EXPR_LITERAL_STRING,
        EXPR_LITERAL_BOOL,
        EXPR_LITERAL_VARIANT,
        EXPR_IDENT,
        EXPR_PARENTHESIZED,
        EXPR_ARR_INDEX,
        EXPR_CALL,
        EXPR_DOT_FIELD_ACCESS,
        EXPR_ARROW_FIELD_ACCESS,
        EXPR_POSTFIX_PLUS_PLUS,

        EXPR_REFERENCE,
        EXPR_DEREFERENCE,
        EXPR_NEGATION,
        EXPR_SIZEOF_EXPR,
        EXPR_SIZEOF_TYPE,

        EXPR_CAST,

        EXPR_ADD,
        EXPR_SUB,

        EXPR_GT,
        EXPR_GTE,
        EXPR_LT,
        EXPR_LTE,

        EXPR_EQUAL,
        EXPR_NOT_EQUAL,

        EXPR_AND,
        EXPR_OR,

        EXPR_ASSIGN,
    },

    as: union {
        literal_int: struct {
            value: int,
        },

        literal_char: struct {
            value: char *,
        },

        literal_string: struct {
            value: char *,
        },

        literal_bool: struct {
            value: bool,
        },

        literal_variant: struct {
            type_name: char *,
            variant_name: char *,
            initializer_list: struct List, // A `List` of `Kwarg`s.
        },

        ident: struct {
            value: char *,
        },

        parenthesized: struct {
            child: struct Expr *,
        },

        arr_index: struct {
            arr: struct Expr *,
            index: struct Expr *,
        },

        call: struct {
            callable: struct Expr *,
            args: struct List,
        },

        field_access: struct {
            object: struct Expr *,
            field: char *,
        },

        postfix_plus_plus: struct {
            operand: struct Expr *,
        },

        unary_op: struct {
            operand: struct Expr *,
        },

        sizeof_expr: struct {
            operand: struct Expr *,
        },

        sizeof_type: struct {
            type: struct Type *,
        },

        cast: struct {
            type: struct Type *,
            expr: struct Expr *,
        },

        binary_op: struct {
            x: struct Expr *,
            y: struct Expr *,
        },

    },
}

fn display_bin_op(out: FILE *, op: char *, x: struct Expr *, y: struct Expr *) -> bool
{
    return display_expr(out, x) &&
           fprintf_s(out, " %s ", op) >= 0 &&
           display_expr(out, y);
}

fn display_literal_variant(
    out: FILE *,
    type_name: char *,
    variant_name: char *,
    initializer_list: struct List
) -> bool
{
    if (!(fprintf_s(out, "(struct %s) {\n", type_name) >= 0))
        return false;

    // Output the tag.
    if (!(fprintf_s(out, ".tag = %s,\n", mangle_variant_tag_name(type_name, variant_name)) >= 0))
        return false;

    // Output the data.
    {
        if (!(fprintf_s(out, ".as = {\n") >= 0))
            return false;

        if (!(fprintf_s(out, ".%s = {\n", mangle_variant_struct_name(type_name, variant_name)) >= 0))
            return false;

        let iter: struct ListNode * = initializer_list.first;
        while (iter)
        {
            let kwarg: struct Kwarg * = (struct Kwarg *) iter->value;

            if (!(fprintf_s(out, ".%s = ", kwarg->field) >= 0))
                return false;
            
            if (!display_expr(out, kwarg->expr))
                return false;

            if (!(fprintf_s(out, ",\n") >= 0))
                return false;

            iter = iter->next;
        }

        if (!(fprintf_s(out, "},\n") >= 0))
            return false;
    }

    if (!(fprintf_s(out, "},\n") >= 0))
        return false;

    return fprintf_s(out, "}") >= 0;
}

fn display_expr(out: FILE *, expr: struct Expr *) -> bool
{
    switch (expr->tag)
    {
    case EXPR_LITERAL_INT:
        return fprintf_s(out, "%d", expr->as.literal_int.value) >= 0;
    case EXPR_LITERAL_CHAR:
        return fprintf_s(out, "'%s'", expr->as.literal_char.value) >= 0;
    case EXPR_LITERAL_STRING:
        return fprintf_s(out, "\"%s\"", expr->as.literal_string.value) >= 0;
    case EXPR_LITERAL_BOOL:
        if (expr->as.literal_bool.value)
            return fprintf_s(out, "true") >= 0;
        else
            return fprintf_s(out, "false") >= 0;
    case EXPR_LITERAL_VARIANT:
        return display_literal_variant(out, expr->as.literal_variant.type_name,
                                            expr->as.literal_variant.variant_name,
                                            expr->as.literal_variant.initializer_list);
    case EXPR_IDENT:
        return fprintf_s(out, "%s", expr->as.ident.value) >= 0;
    case EXPR_PARENTHESIZED:
        return fprintf_s(out, "(") >= 0 &&
               display_expr(out, expr->as.parenthesized.child) &&
               fprintf_s(out, ")") >= 0;
    case EXPR_ARR_INDEX:
        return display_expr(out, expr->as.arr_index.arr) &&
               fprintf_s(out, "[") >= 0 &&
               display_expr(out, expr->as.arr_index.index) &&
               fprintf_s(out, "]") >= 0;
    case EXPR_CALL:
        return display_expr(out, expr->as.call.callable) &&
               fprintf_s(out, "(") >= 0 &&
               display_arglist(out, &expr->as.call.args) &&
               fprintf_s(out, ")") >= 0;
    case EXPR_DOT_FIELD_ACCESS:
        return display_expr(out, expr->as.field_access.object) &&
               fprintf_s(out, ".%s", expr->as.field_access.field) >= 0;
    case EXPR_ARROW_FIELD_ACCESS:
        return display_expr(out, expr->as.field_access.object) &&
               fprintf_s(out, "->%s", expr->as.field_access.field) >= 0;
    case EXPR_POSTFIX_PLUS_PLUS:
        return display_expr(out, expr->as.postfix_plus_plus.operand) &&
               fprintf_s(out, "++") >= 0;
    case EXPR_REFERENCE:
        return fprintf_s(out, "&") >= 0 &&
               display_expr(out, expr->as.unary_op.operand);
    case EXPR_DEREFERENCE:
        return fprintf_s(out, "*") >= 0 &&
               display_expr(out, expr->as.unary_op.operand);
    case EXPR_NEGATION:
        return fprintf_s(out, "!") >= 0 &&
               display_expr(out, expr->as.unary_op.operand);
    case EXPR_SIZEOF_EXPR:
        return fprintf_s(out, "sizeof ") >= 0 &&
               display_expr(out, expr->as.sizeof_expr.operand);
    case EXPR_SIZEOF_TYPE:
        return fprintf_s(out, "sizeof(") >= 0 &&
               display_type(out, expr->as.sizeof_type.type) &&
               fprintf_s(out, ")") >= 0;
    case EXPR_CAST:
        return fprintf_s(out, "(") >= 0 &&
               display_type(out, expr->as.cast.type) &&
               fprintf_s(out, ") ") >= 0 &&
               display_expr(out, expr->as.cast.expr);
    case EXPR_ADD:
        return display_bin_op(out, "+", expr->as.binary_op.x, expr->as.binary_op.y);
    case EXPR_SUB:
        return display_bin_op(out, "-", expr->as.binary_op.x, expr->as.binary_op.y);
    case EXPR_GT:
        return display_bin_op(out, ">", expr->as.binary_op.x, expr->as.binary_op.y);
    case EXPR_GTE:
        return display_bin_op(out, ">=", expr->as.binary_op.x, expr->as.binary_op.y);
    case EXPR_LT:
        return display_bin_op(out, "<", expr->as.binary_op.x, expr->as.binary_op.y);
    case EXPR_LTE:
        return display_bin_op(out, "<=", expr->as.binary_op.x, expr->as.binary_op.y);
    case EXPR_EQUAL:
        return display_bin_op(out, "==", expr->as.binary_op.x, expr->as.binary_op.y);
    case EXPR_NOT_EQUAL:
        return display_bin_op(out, "!=", expr->as.binary_op.x, expr->as.binary_op.y);
    case EXPR_AND:
        return display_bin_op(out, "&&", expr->as.binary_op.x, expr->as.binary_op.y);
    case EXPR_OR:
        return display_bin_op(out, "||", expr->as.binary_op.x, expr->as.binary_op.y);
    case EXPR_ASSIGN:
        return display_bin_op(out, "=", expr->as.binary_op.x, expr->as.binary_op.y);
    }
}

fn display_arglist(out: FILE *, list: struct List *) -> bool
{
    let node: struct ListNode * = list->first;

    while (node)
    {
        let expr: struct Expr * = (struct Expr *)node->value;

        if (node->next)
        {
            let result: bool = display_expr(out, expr) &&
                               fprintf_s(out, ", ") >= 0;

            if (!result)
                return false;

            node = node->next;
        }
        else
        {
            // Don't display the comma.
            return display_expr(out, expr);
        }
    }

    return true;
}

// Holds like `sum: a + b` for when initializing a struct.
struct Kwarg {
    field: char *,
    expr: struct Expr *,
}

// Returns a `List` of `Kwarg`s.
// Grammar:
// struct_initializer_list ::=
//     ('ident' '=' expression (',' 'ident' '=' expression)* ','?)?
fn parse_struct_initializer_list(lxr: struct Lexer *) -> struct List
{
    let list: struct List = list_init();

    while (lexer_accept(lxr, TOK_IDENT))
    {
        let field: char * = lxr->token;
        let kwarg: struct Kwarg * = malloc(sizeof(*kwarg));
        kwarg->field = field;

        let expr: struct Expr *;

        // If you get an `=` sign, it means we need to parse an arbitrary expression for `expr`.
        if (lexer_accept(lxr, TOK_EQUAL))
        {
            if (!(expr = parse_expression(lxr)))
                todo; // TODO: report error
        } else {
            // Otherwise, `expr` is just an identifier of the same name as the field.
            expr = malloc(sizeof(*expr));
            expr->tag = EXPR_IDENT;
            expr->as.ident.value = field;
        }

        kwarg->expr = expr;

        list_push(&list, (void *) kwarg);

        // Allow optional trailing comma.
        if (!lexer_accept(lxr, TOK_COMMA))
            break;
    }

    return list;
}

// PrimaryExpression
//    <- StringLiteral
//     / Constant
//     / Identifier
//     / LPAR Expression RPAR
fn parse_primary_expression(lxr: struct Lexer *) -> struct Expr *
{
    let expr: struct Expr *;

    if (lexer_accept(lxr, TOK_LITERAL_STRING))
    {
        expr = malloc(sizeof(*expr));
        expr->tag = EXPR_LITERAL_STRING;
        expr->as.literal_string.value = lxr->token;
        return expr;
    }

    if ((expr = parse_constant(lxr)))
    {
        return expr;
    }

    if (lexer_accept(lxr, TOK_IDENT))
    {
        let name: char * = lxr->token;

        // VARIANT LITERAL
        if (lexer_accept(lxr, TOK_COLON_COLON))
        {
            let type_name: char * = name;

            lexer_expect(lxr, TOK_IDENT);
            let variant_name: char * = lxr->token;
            lexer_expect(lxr, TOK_OPEN_BRACE);
            let init_list: struct List = parse_struct_initializer_list(lxr);
            lexer_expect(lxr, TOK_CLOSE_BRACE);

            expr = malloc(sizeof(*expr));
            expr->tag = EXPR_LITERAL_VARIANT;
            expr->as.literal_variant.type_name = type_name;
            expr->as.literal_variant.variant_name = variant_name;
            expr->as.literal_variant.initializer_list = init_list;
            return expr;
        } else {
            // IDENTIFIER
            expr = malloc(sizeof(*expr));
            expr->tag = EXPR_IDENT;
            expr->as.ident.value = name;
            return expr;
        }
    }

    if (lexer_accept(lxr, TOK_OPEN_PAREN) &&
        (expr = parse_expression(lxr)) &&
        lexer_expect(lxr, TOK_CLOSE_PAREN))
    {
        // NOTE: We need to store parenthesized exprs as their own AST node so
        // that they can be printed into the output file without changing
        // precedence of operations.
        let paren_expr: struct Expr * = malloc(sizeof(*paren_expr));
        paren_expr->tag = EXPR_PARENTHESIZED;
        paren_expr->as.parenthesized.child = expr;
        return paren_expr;
    }

    return NULL;
}

// PostfixExpression
//    <- ( PrimaryExpression
//       / LPAR TypeName RPAR LWING InitializerList COMMA? RWING  # :TODO: parse compound literals https://en.cppreference.com/w/c/language/compound_literal
//       )
//       ( LBRK Expression RBRK
//       / LPAR ArgumentExpressionList? RPAR
//       / DOT Identifier
//       / PTR Identifier
//       / INC
//       / DEC          # :IGNORED
//       )*
fn parse_postfix_expression(lxr: struct Lexer *) -> struct Expr *
{
    let expr: struct Expr *;

    if (!(expr = parse_primary_expression(lxr)))
        return NULL;

    while (true)
    {

        // ARRAY INDEX EXPRESSION
        let index: struct Expr *;
        if (lexer_accept(lxr, TOK_OPEN_BRACK) &&
            (index = parse_expression(lxr)) &&
            lexer_expect(lxr, TOK_CLOSE_BRACK))
        {
            let new_expr: struct Expr * = malloc(sizeof(*new_expr));
            new_expr->tag = EXPR_ARR_INDEX;
            new_expr->as.arr_index.arr = expr;
            new_expr->as.arr_index.index = index;

            expr = new_expr;
            continue;
        }

        // FUNCTION CALL
        if (lexer_accept(lxr, TOK_OPEN_PAREN))
        {
            let arg_list: struct List = parse_argument_expression_list(lxr);
            lexer_expect(lxr, TOK_CLOSE_PAREN);

            let new_expr: struct Expr * = malloc(sizeof(*new_expr));
            new_expr->tag = EXPR_CALL;
            new_expr->as.call.callable = expr;
            new_expr->as.call.args = arg_list;

            expr = new_expr;
            continue;
        }

        // DOT FIELD ACCESS
        if (lexer_accept(lxr, TOK_DOT) &&
            lexer_expect(lxr, TOK_IDENT))
        {
            let new_expr: struct Expr * = malloc(sizeof(*new_expr));
            new_expr->tag = EXPR_DOT_FIELD_ACCESS;
            new_expr->as.field_access.object = expr;
            new_expr->as.field_access.field = lxr->token;

            expr = new_expr;
            continue;
        }

        // ARROW FIELD ACCESS
        if (lexer_accept(lxr, TOK_ARROW) &&
            lexer_expect(lxr, TOK_IDENT))
        {
            let new_expr: struct Expr * = malloc(sizeof(*new_expr));
            new_expr->tag = EXPR_ARROW_FIELD_ACCESS;
            new_expr->as.field_access.object = expr;
            new_expr->as.field_access.field = lxr->token;

            expr = new_expr;
            continue;
        }

        // POSTFIX PLUS PLUS
        if (lexer_accept(lxr, TOK_PLUS_PLUS))
        {
            let new_expr: struct Expr * = malloc(sizeof(*new_expr));
            new_expr->tag = EXPR_POSTFIX_PLUS_PLUS;
            new_expr->as.postfix_plus_plus.operand = expr;

            expr = new_expr;
            continue;
        }

        break;
    }
    return expr;
}

// ArgumentExpressionList
//      <- <empty string>
//       / AssignmentExpression (COMMA AssignmentExpression)*
fn parse_argument_expression_list(lxr: struct Lexer *) -> struct List
{
    let expr: struct Expr *;
    let list: struct List = list_init();

    if (!(expr = parse_assignment_expression(lxr)))
        return list;

    list_push(&list, (void *)expr);

    while (lexer_accept(lxr, TOK_COMMA))
    {
        if (!(expr = parse_assignment_expression(lxr)))
            break;

        list_push(&list, (void *)expr);
    }

    return list;
}

// UnaryExpression
//    <- PostfixExpression
//     / INC UnaryExpression # :IGNORED
//     / DEC UnaryExpression # :IGNORED
//     / UnaryOperator CastExpression
//     / SIZEOF (UnaryExpression / LPAR TypeName RPAR )
//
// UnaryOperator
//    <- AND
//     / STAR
//     / PLUS # :IGNORED
//     / MINUS # :IGNORED
//     / TILDA # :IGNORED
//     / BANG
//
// TODO: remove backtracking by rewriting grammar slightly:
//   unary_expression -> 'sizeof' unary_expression'
//                     | 'constant'
//                     | '(' expression ')'
//  unary_expression' -> 'sizeof' unary_expression'
//                     | 'constant'
//                     | '(' expression ')'
//                     | '(' type_name ')'
fn parse_unary_expression(lxr: struct Lexer *) -> struct Expr *
{
    let expr: struct Expr *;

    if ((expr = parse_postfix_expression(lxr)))
        return expr;

    if (lexer_accept(lxr, TOK_AMPERSAND))
    {
        let operand: struct Expr *;
        if (!(operand = parse_cast_expression(lxr)))
            return NULL;

        expr = malloc(sizeof(*expr));
        expr->tag = EXPR_REFERENCE;
        expr->as.unary_op.operand = operand;
        return expr;
    }

    if (lexer_accept(lxr, TOK_STAR))
    {
        let operand: struct Expr *;
        if (!(operand = parse_cast_expression(lxr)))
            return NULL;

        expr = malloc(sizeof(*expr));
        expr->tag = EXPR_DEREFERENCE;
        expr->as.unary_op.operand = operand;
        return expr;
    }

    if (lexer_accept(lxr, TOK_BANG))
    {
        let operand: struct Expr *;
        if (!(operand = parse_cast_expression(lxr)))
            return NULL;

        expr = malloc(sizeof(*expr));
        expr->tag = EXPR_NEGATION;
        expr->as.unary_op.operand = operand;
        return expr;
    }

    if (lexer_accept(lxr, TOK_SIZEOF))
    {
        let operand: struct Expr *;
        {
            let saved_lxr: struct Lexer = *lxr; // HACK: save lexer state
            if ((operand = parse_unary_expression(lxr)))
            {
                expr = malloc(sizeof(*expr));
                expr->tag = EXPR_SIZEOF_EXPR;
                expr->as.sizeof_expr.operand = operand;
                return expr;
            }
            *lxr = saved_lxr; // HACK: restore lexer state
        }

        let type: struct Type *;
        if (lexer_accept(lxr, TOK_OPEN_PAREN) &&
            (type = parse_type(lxr)) &&
            lexer_expect(lxr, TOK_CLOSE_PAREN))
        {
            expr = malloc(sizeof(*expr));
            expr->tag = EXPR_SIZEOF_TYPE;
            expr->as.sizeof_type.type = type;
            return expr;
        }

        return NULL;
    }

    return NULL;
}

// CastExpression
//      <- (LPAR TypeName RPAR CastExpression)
//       / UnaryExpression
//
// TODO: remove backtracking by rewriting grammar slightly:
//    cast_expression -> '(' type_name ')' cast_expression
//                     | 'sizeof' unary_expression'
//                     | 'constant'
//                     | '(' expression ')'
//  unary_expression' -> 'sizeof' unary_expression'
//                     | 'constant'
//                     | '(' expression ')'
//                     | '(' type_name ')'
fn parse_cast_expression(lxr: struct Lexer *) -> struct Expr *
{
    {
        let saved_lxr: struct Lexer = *lxr; // HACK: is there a better way?
        {
            let type: struct Type *;
            let expr: struct Expr *;
            if (lexer_accept(lxr, TOK_OPEN_PAREN) &&
                (type = parse_type(lxr)) &&
                lexer_accept(lxr, TOK_CLOSE_PAREN) &&
                (expr = parse_cast_expression(lxr)))
            {
                let cast_expr: struct Expr * = malloc(sizeof(*cast_expr));
                cast_expr->tag = EXPR_CAST;
                cast_expr->as.cast.type = type;
                cast_expr->as.cast.expr = expr;
                return cast_expr;
            }
        }
        *lxr = saved_lxr;
    }

    return parse_unary_expression(lxr);
}

// MultiplicativeExpression
//      <- CastExpression ((STAR / DIV / MOD) CastExpression)*
fn parse_multiplicative_expression(lxr: struct Lexer *) -> struct Expr *
{
    // TODO: impl multiplication, division, modulo
    return parse_cast_expression(lxr);
}

// AdditiveExpression
//      <- MultiplicativeExpression ((PLUS / MINUS) MultiplicativeExpression)*
fn parse_additive_expression(lxr: struct Lexer *) -> struct Expr *
{
    let accum: struct Expr *;

    if (!(accum = parse_multiplicative_expression(lxr)))
        return NULL;

    while (lexer_accept(lxr, TOK_PLUS) || lexer_accept(lxr, TOK_MINUS))
    {
        let y: struct Expr *;

        // Save the token type.
        let op: enum TokTag = lxr->tok_tag;

        if (!(y = parse_multiplicative_expression(lxr)))
        {
            fprintf_s(stderr, "PARSE ERROR: %s:%d\n", lxr->filename, lxr->line);
            fprintf_s(stderr, "| expected expression after `%s`, got nothing\n", tok_tag_names[op]);
            exit(1);
        }

        let new_expr: struct Expr * = malloc(sizeof(*new_expr));
        new_expr->as.binary_op.x = accum;
        new_expr->as.binary_op.y = y;
        if (op == TOK_PLUS)
            new_expr->tag = EXPR_ADD;
        else
            new_expr->tag = EXPR_SUB;

        accum = new_expr;
    }

    return accum;
}

// ShiftExpression
//      <- AdditiveExpression ((LEFT / RIGHT) AdditiveExpression)*
fn parse_shift_expression(lxr: struct Lexer *) -> struct Expr *
{
    return parse_additive_expression(lxr);
}

// RelationalExpression
//      <- ShiftExpression ((LE / GE / LT / GT) ShiftExpression)*
fn parse_relational_expression(lxr: struct Lexer *) -> struct Expr *
{
    let accum: struct Expr *;

    if (!(accum = parse_shift_expression(lxr)))
        return NULL;

    while (lexer_accept(lxr, TOK_LTE) ||
           lexer_accept(lxr, TOK_GTE) ||
           lexer_accept(lxr, TOK_LT) ||
           lexer_accept(lxr, TOK_GT))
    {
        let y: struct Expr *;

        // Save the token type.
        let op: enum TokTag = lxr->tok_tag;

        if (!(y = parse_shift_expression(lxr)))
        {
            fprintf_s(stderr, "PARSE ERROR: %s:%d\n", lxr->filename, lxr->line);
            fprintf_s(stderr, "| expected expression after `%s`, got nothing\n", tok_tag_names[op]);
            exit(1);
        }

        let new_expr: struct Expr * = malloc(sizeof(*new_expr));
        new_expr->as.binary_op.x = accum;
        new_expr->as.binary_op.y = y;
        if (op == TOK_LTE)
            new_expr->tag = EXPR_LTE;
        else if (op == TOK_GTE)
            new_expr->tag = EXPR_GTE;
        else if (op == TOK_LT)
            new_expr->tag = EXPR_LT;
        else if (op == TOK_GT)
            new_expr->tag = EXPR_GT;

        accum = new_expr;
    }

    return accum;
}

// EqualityExpression
//      <- RelationalExpression ((EQUEQU / BANGEQU) RelationalExpression)*
fn parse_equality_expression(lxr: struct Lexer *) -> struct Expr *
{
    let accum: struct Expr *;

    if (!(accum = parse_relational_expression(lxr)))
        return NULL;

    while (lexer_accept(lxr, TOK_EQUAL_EQUAL) ||
           lexer_accept(lxr, TOK_NOT_EQUAL))
    {
        let y: struct Expr *;

        // Save the token type.
        let op: enum TokTag = lxr->tok_tag;

        if (!(y = parse_relational_expression(lxr)))
        {
            fprintf_s(stderr, "PARSE ERROR: %s:%d\n", lxr->filename, lxr->line);
            fprintf_s(stderr, "| expected expression after `%s`, got nothing\n", tok_tag_names[op]);
            exit(1);
        }

        let new_expr: struct Expr * = malloc(sizeof(*new_expr));
        new_expr->as.binary_op.x = accum;
        new_expr->as.binary_op.y = y;
        if (op == TOK_EQUAL_EQUAL)
            new_expr->tag = EXPR_EQUAL;
        else if (op == TOK_NOT_EQUAL)
            new_expr->tag = EXPR_NOT_EQUAL;

        accum = new_expr;
    }

    return accum;
}

// :IGNORED
// ANDExpression <- EqualityExpression (AND EqualityExpression)*

// :IGNORED
// ExclusiveORExpression <- ANDExpression (HAT ANDExpression)*

// :IGNORED
// InclusiveORExpression <- ExclusiveORExpression (OR ExclusiveORExpression)*

// LogicalANDExpression
//      <- InclusiveORExpression (ANDAND InclusiveORExpression)*
fn parse_logical_and_expression(lxr: struct Lexer *) -> struct Expr *
{
    let accum: struct Expr *;

    if (!(accum = parse_equality_expression(lxr)))
        return NULL;

    while (lexer_accept(lxr, TOK_AND))
    {
        let y: struct Expr *;

        if (!(y = parse_equality_expression(lxr)))
        {
            fprintf_s(stderr, "PARSE ERROR: %s:%d\n", lxr->filename, lxr->line);
            fprintf_s(stderr, "| expected expression after `&&`, got nothing\n");
            exit(1);
        }

        let new_expr: struct Expr * = malloc(sizeof(*new_expr));
        new_expr->tag = EXPR_AND;
        new_expr->as.binary_op.x = accum;
        new_expr->as.binary_op.y = y;

        accum = new_expr;
    }

    return accum;
}

// LogicalORExpression
//      <- LogicalANDExpression (OROR LogicalANDExpression)*
fn parse_logical_or_expression(lxr: struct Lexer *) -> struct Expr *
{
    let accum: struct Expr *;

    if (!(accum = parse_logical_and_expression(lxr)))
        return NULL;

    while (lexer_accept(lxr, TOK_OR))
    {
        let y: struct Expr *;

        if (!(y = parse_logical_and_expression(lxr)))
        {
            fprintf_s(stderr, "PARSE ERROR: %s:%d\n", lxr->filename, lxr->line);
            fprintf_s(stderr, "| expected expression after `||`, got nothing\n");
            exit(1);
        }

        let new_expr: struct Expr * = malloc(sizeof(*new_expr));
        new_expr->tag = EXPR_OR;
        new_expr->as.binary_op.x = accum;
        new_expr->as.binary_op.y = y;

        accum = new_expr;
    }

    return accum;
}

// ConditionalExpression
//      <- LogicalORExpression (QUERY Expression COLON LogicalORExpression)* # :IGNORED
fn parse_conditional_expression(lxr: struct Lexer *) -> struct Expr *
{
    return parse_logical_or_expression(lxr);
}

// AssignmentExpression
//    <- UnaryExpression AssignmentOperator AssignmentExpression
//     / ConditionalExpression
//
// AssignmentOperator
//    <- EQU
//     / STAREQU  # :IGNORED
//     / DIVEQU   # :IGNORED
//     / MODEQU   # :IGNORED
//     / PLUSEQU  # :IGNORED
//     / MINUSEQU # :IGNORED
//     / LEFTEQU  # :IGNORED
//     / RIGHTEQU # :IGNORED
//     / ANDEQU   # :IGNORED
//     / HATEQU   # :IGNORED
//     / OREQU    # :IGNORED
//
// TODO: remove backtracking by left factoring grammar:
//  assignment_expression -> 'sizeof' unary_expression' '=' assignment_expression
//                         | 'constant' '=' assignment_expression
//                         | '(' expression ')' '=' assignment_expression
//                         | conditional_expression
// conditional_expression -> '(' type_name ')' cast_expression
//                         | 'sizeof' unary_expression'
//                         | 'constant'
//                         | '(' expression ')'
//      unary_expression' -> 'sizeof' unary_expression'
//                         | 'constant'
//                         | '(' expression ')'
//                         | '(' type_name ')'
fn parse_assignment_expression(lxr: struct Lexer *) -> struct Expr *
{
    let unary: struct Expr *;
    let assignment: struct Expr *;

    {
        let saved_lxr: struct Lexer = *lxr; // HACK: backtracking hack
        if ((unary = parse_unary_expression(lxr)) &&
            lexer_accept(lxr, TOK_EQUAL) &&
            (assignment = parse_assignment_expression(lxr)))
        {
            let expr: struct Expr * = malloc(sizeof(*expr));
            expr->tag = EXPR_ASSIGN;
            expr->as.binary_op.x = unary;
            expr->as.binary_op.y = assignment;
            return expr;
        }
        *lxr = saved_lxr;
    }

    return parse_conditional_expression(lxr);
}

// Expression
//      <- AssignmentExpression (COMMA AssignmentExpression)* # :IGNORED
fn parse_expression(lxr: struct Lexer *) -> struct Expr *
{
    return parse_assignment_expression(lxr);
}

// #-------------------------------------------------------------------------
// #  A.1.5  Constants
// #-------------------------------------------------------------------------

// Constant
//    <- FloatConstant         # :TODO
//     / IntegerConstant       # Note: can be a prefix of Float Constant!
//     / EnumerationConstant   # :IGNORED
//     / BooleanConstant       # :NEW
//     / CharacterConstant
fn parse_constant(lxr: struct Lexer *) -> struct Expr *
{
    if (lexer_accept(lxr, TOK_LITERAL_INT))
    {
        let expr: struct Expr * = malloc(sizeof(*expr));
        expr->tag = EXPR_LITERAL_INT;
        expr->as.literal_int.value = atoi(lxr->token);
        return expr;
    }

    if (lexer_accept(lxr, TOK_TRUE) || lexer_accept(lxr, TOK_FALSE))
    {
        let expr: struct Expr * = malloc(sizeof(*expr));
        expr->tag = EXPR_LITERAL_BOOL;
        expr->as.literal_bool.value = (lxr->tok_tag == TOK_TRUE);
        return expr;
    }

    if (lexer_accept(lxr, TOK_LITERAL_CHAR))
    {
        let expr: struct Expr * = malloc(sizeof(*expr));
        expr->tag = EXPR_LITERAL_CHAR;
        expr->as.literal_char.value = lxr->token;
        return expr;
    }

    return NULL;
}
